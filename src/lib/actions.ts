"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { AnalyzeSymptomsOutput } from "@/ai/flows/analyze-symptoms";
import type { SymptomReport } from "@/types";
import { revalidatePath } from "next/cache";

export async function saveSymptomReportAction({
  symptomDescription,
  scanFindingsDescription,
  analysisResult,
  reportFileDataUri,
}: {
  symptomDescription: string;
  scanFindingsDescription?: string;
  analysisResult: AnalyzeSymptomsOutput;
  reportFileDataUri?: string;
}): Promise<{ data: SymptomReport | null; error: string | null }> {
  const supabase = createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { data: null, error: "User not authenticated" };
  }

  const { data, error } = await supabase
    .from("symptom_reports")
    .insert([
      {
        user_id: user.id,
        symptom_description: symptomDescription,
        scan_findings_description: scanFindingsDescription,
        analysis_result: analysisResult,
        report_file_data_uri: reportFileDataUri,
      },
    ])
    .select()
    .single();

  if (error) {
    console.error("Error saving report:", error);
    return { data: null, error: error.message };
  }

  revalidatePath("/dashboard/history");
  return { data: data as SymptomReport, error: null };
}

export async function getSymptomReportsAction(): Promise<{
  reports: SymptomReport[];
  error: string | null;
}> {
  const supabase = createSupabaseServerClient();
  const {
    data: { user },
  } = await supabase.auth.getUser();

  if (!user) {
    return { reports: [], error: "User not authenticated" };
  }

  const { data, error } = await supabase
    .from("symptom_reports")
    .select("*")
    .eq("user_id", user.id)
    .order("created_at", { ascending: false });

  if (error) {
    console.error("Error fetching reports:", error);
    return { reports: [], error: error.message };
  }

  return { reports: data as SymptomReport[], error: null };
}

/*
-- =================================================================
-- SUPABASE SCHEMA FOR SymptomHelp AI
-- This script can be run in the Supabase SQL Editor.
-- =================================================================

-- Create the symptom_reports table
CREATE TABLE IF NOT EXISTS public.symptom_reports (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
  symptom_description TEXT NOT NULL,
  scan_findings_description TEXT,
  report_file_data_uri TEXT,
  analysis_result JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Add comments to the table and columns for clarity
COMMENT ON TABLE public.symptom_reports IS 'Stores symptom analysis reports generated by users.';
COMMENT ON COLUMN public.symptom_reports.id IS 'Unique identifier for the symptom report.';
COMMENT ON COLUMN public.symptom_reports.user_id IS 'Foreign key referencing the user who created the report.';
COMMENT ON COLUMN public.symptom_reports.symptom_description IS 'User-provided description of their symptoms.';
COMMENT ON COLUMN public.symptom_reports.scan_findings_description IS 'User-provided description of medical scan findings (e.g., X-ray, MRI).';
COMMENT ON COLUMN public.symptom_reports.report_file_data_uri IS 'Stores the uploaded report file (image or PDF) as a Base64 encoded Data URI.';
COMMENT ON COLUMN public.symptom_reports.analysis_result IS 'JSONB storing the AI analysis output, including potential diagnoses and confidence levels.';
COMMENT ON COLUMN public.symptom_reports.created_at IS 'Timestamp of when the report was created.';

-- Enable Row Level Security (RLS) for the symptom_reports table
ALTER TABLE public.symptom_reports ENABLE ROW LEVEL SECURITY;

-- Policy: Allow authenticated users to insert their own reports
CREATE POLICY "Allow individual insert access for their own reports"
  ON public.symptom_reports
  FOR INSERT
  TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Policy: Allow authenticated users to select (read) their own reports
CREATE POLICY "Allow individual read access to their own reports"
  ON public.symptom_reports
  FOR SELECT
  TO authenticated
  USING (auth.uid() = user_id);

-- Note: The following policies for UPDATE and DELETE are commented out by default.
-- Uncomment them if you want to provide users with the ability to edit or delete their reports.

-- CREATE POLICY "Allow individual update access for their own reports"
--   ON public.symptom_reports
--   FOR UPDATE
--   TO authenticated
--   USING (auth.uid() = user_id)
--   WITH CHECK (auth.uid() = user_id);

-- CREATE POLICY "Allow individual delete access for their own reports"
--   ON public.symptom_reports
--   FOR DELETE
--   TO authenticated
--   USING (auth.uid() = user_id);
*/
